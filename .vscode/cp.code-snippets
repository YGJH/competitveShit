{
    // Place your c-_project 工作區 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
	"cppcode" : {
		"scope":"cpp",
		"prefix":"cppcode",
		"body":[
			"#include <bits/stdc++.h>",
"using namespace std;",
"",
"#define int i64",
"#define FF first",
"#define SS second",
"#define SZ(x) ((i32)(x).size())",
"#define PB push_back",
"#define EB emplace_back",
"#define all(x) (x).begin(), (x).end()",
"using i128 = __int128_t;",
"using ui64 = uint64_t;",
"using i64 = int64_t;",
"using ui32 = uint32_t;",
"using i32 = int32_t;",
"using ld = long double;",
"using P32 = pair<i32, i32>;",
"using P64 = pair<i64, i64>;",
"const i64 INF = 1e18;",
"const ld eps = 1e-8L;",
"",
"#ifdef LOCAL",
"void debug() {}",
"template<class T> void debug(T var) { cerr << var; }",
"template<class T, class ...P> void debug(T var, P ...t) { cerr << var << \", \"; debug(t...); }",
"template<class T> void org(T l, T r) { while(l != r) cerr << *l++ << ' '; }",
"#define de(...) { cerr << \"[Line: \" << __LINE__ << \"][\" << #__VA_ARGS__ << \"] -> [\", debug(__VA_ARGS__), cerr << \"]\\n\"; }",
"#define orange(...) { cerr << \"[Line: \" << __LINE__ << \"][\" << #__VA_ARGS__ << \"] -> [\", org(__VA_ARGS__), cerr << \"]\\n\"; }",
"#else",
"#define de(...) ((void)0)",
"#define orange(...) ((void)0)",
"#endif",
"",
"namespace IO {",
"const i32 msize = 200000;",
"char buf[msize], *p1 = buf, *p2 = buf;",
"char obuf[msize], *p3 = obuf;",
"#define getc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, msize, stdin), p1 == p2) ? EOF : *p1++)",
"#define putac(x) (p3 - obuf < msize) ? (*p3 ++ = x) :(fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3 ++ = x)",
"template<class T> inline void read(T &x) {",
"    x = 0;",
"    i32 f = 1;",
"    char ch = getc();",
"    for (; ch < 48 || ch > 57; ch = getc()) if (ch == '-') f = -1;",
"    for (; ch >= 48 && ch <= 57; ch = getc()) x = (x << 3) + (x << 1) + (ch ^ 0x30);",
"    x = x * f;",
"}",
"template<class T> void write(const T &x) {",
"    static i32 c[40];",
"    if (!x) { putac('0'); return; }",
"    i32 len = 0;",
"    T k1 = x;",
"    if (k1 < 0) k1 = -k1, putac('-');",
"    while (k1) c[len++] = k1 % 10 ^ 48, k1 /= 10;",
"    while (len--) putac(c[len]);",
"}",
"void write(const char *str) { while (*str) putac(*str++); }",
"void write(const string &str) { for (char c : str) putac(c); }",
"void write(const char &c) { putac(c); }",
"template<typename T, typename... Args>",
"inline void read(T &x, Args&... args) {",
"    read(x);",
"    read(args...);",
"}",
"template<typename T, typename... Args>",
"inline void write(const T &x, const Args&... args) {",
"    write(x);",
"    write(args...);",
"}",
"inline void flush() { fwrite(obuf, p3 - obuf, 1, stdout); }",
"}",
"using IO::read;",
"using IO::write;",
"struct xout {",
"    template<typename T>",
"    xout& operator << (const T &x) {",
"        IO::write(x);",
"        return *this;",
"    }",
"} xout;",
"struct xin {",
"    template<typename T>",
"    xin& operator >> (T &x) {",
"        IO::read(x);",
"        return *this;",
"    }",
"} xin;",
		]
	}
    "ddff": {
        "scope": "cpp",
        "prefix": "ddff",
        "body":[
            "#define piyan puts(\"操我屁眼\");",
            "#define fk puts(\"幹你娘幹你娘\");",
            "#define int i64",
            "#define FF first",
            "#define SS second",
            "#define SZ(x) ((i32)(x).size())",
            "#define PB push_back",
            "#define EB emplace_back",
            "#define all(x) (x).begin(), (x).end()",
            "using i128 = __int128_t;",
            "using ui64 = uint64_t;",
            "using i64 = int64_t;",
            "using ui32 = uint32_t;",
            "using i32 = int32_t;",
            "using ld = long double;",
            "using P32 = pair<i32, i32>;",
            "using P64 = pair<i64, i64>;",
            "const i64 INF = 1e18;",
            "const ld eps = 1e-8L;",
        ],
        "description": "define"
    },
    "ishowspeed": {
        "scope": "cpp",
        "prefix": [
            "ishowspeed"
        ],
        "body": [
            "ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);"
        ],
        "description": "default code"
    },
    "beebug" :{
        "scope": "cpp",
        "prefix": "beebug",
        "body": [
            "#ifdef LOCAL",
            "void debug() {}",
            "template<class T> void debug(T var) { cerr << var; }",
            "template<class T, class ...P> void debug(T var, P ...t) { cerr << var << \", \"; debug(t...); }",
            "template<class T> void org(T l, T r) { while(l != r) cerr << *l++ << ' '; }",
            "#define de(...) { cerr << \"[Line: \" << __LINE__ << \"][\" << #__VA_ARGS__ << \"] -> [\", debug(__VA_ARGS__), cerr << \"]\\n\"; }",
            "#define orange(...) { cerr << \"[Line: \" << __LINE__ << \"][\" << #__VA_ARGS__ << \"] -> [\", org(__VA_ARGS__), cerr << \"]\\n\"; }",
            "#else",
            "#define de(...) ((void)0)",
            "#define orange(...) ((void)0)",
            "#endif",
        ],
        "description": "debug"
    },
    "fastio": { 
        "scope": "cpp",
        "prefix": [
            "fastio"
        ],
        "body": [
            "namespace IO {",
			"const i32 msize = 200000;",
			"char buf[msize], *p1 = buf, *p2 = buf;",
			"char obuf[msize], *p3 = obuf;",
			"#define getc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, msize, stdin), p1 == p2) ? EOF : *p1++)",
			"#define putac(x) (p3 - obuf < msize) ? (*p3 ++ = x) :(fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3 ++ = x)",
			"template<class T> inline void read(T &x) {",
			"x = 0;",
			"i32 f = 1;",
			"char ch = getc();",
			"for (; ch < 48 || ch > 57; ch = getc()) if (ch == '-') f = -1;",
			"for (; ch >= 48 && ch <= 57; ch = getc()) x = (x << 3) + (x << 1) + (ch ^ 0x30);",
			"x = x * f;",
			"}",
			"template<class T> void write(const T &x) {",
			"static i32 c[40];",
			"if (!x) { putac('0'); return; }",
			"i32 len = 0;",
			"T k1 = x;",
			"if (k1 < 0) k1 = -k1, putac('-');",
			"while (k1) c[len++] = k1 % 10 ^ 48, k1 /= 10;",
			"while (len--) putac(c[len]);",
			"}",
			"void write(const char *str) { while (*str) putac(*str++); }",
			"void write(const string &str) { for (char c : str) putac(c); }",
			"void write(const char &c) { putac(c); }",
			"template<typename T, typename... Args>",
			"inline void read(T &x, Args&... args) {",
			"read(x);  // 讀取第一個變數",
			"read(args...); // 展開剩餘變數的讀取",
			"}",
			"template<typename T, typename... Args>",
			"inline void write(const T &x, const Args&... args) {",
			"write(x);",
			"write(args...);",
			"}",
			"inline void flush() { fwrite(obuf, p3 - obuf, 1, stdout); }",
			"}",
			"using IO::read;",
			"using IO::write;",
        ],
        "description": "default code"
    },
    "pragma": {
        "scope": "cpp",
        "prefix": [
            "pragma"
        ],
        "body": [
            "#pragma GCC optimize(1,2,3,\"Ofast\",\"inline\")",
            "#pragma GCC optimize(\"O3,unroll-loops\")",
        ]
    },
    "Dinic": {
        "scope": "cpp",
        "prefix": "Dinic",
        "body": [
            "#define SZ(X) (int)(X).size()",
			"#define PB push_back",
			"constexpr int MXN = 1e5+4;",
			"struct Dinic",
			"{",
			"    struct Edge",
			"    {",
			"        int v, f, re;",
			"    };",
			"    int n, s, t, level[MXN];",
			"    vector<Edge> E[MXN];",
			"    void init(int _n, int _s, int _t)",
			"    {",
			"        n = _n;",
			"        s = _s;",
			"        t = _t;",
			"        for (int i = 0; i < n; i++)",
			"            E[i].clear();",
			"    }",
			"    void add_edge(int u, int v, int f)",
			"    {",
			"        E[u].PB({v, f, SZ(E[v])});",
			"        E[v].PB({u, 0, SZ(E[u]) - 1});",
			"    }",
			"    bool BFS()",
			"    {",
			"        for (int i = 0; i < n; i++)",
			"            level[i] = -1;",
			"        queue<int> que;",
			"        que.push(s);",
			"        level[s] = 0;",
			"        while (!que.empty())",
			"        {",
			"            int u = que.front();",
			"            que.pop();",
			"            for (auto it : E[u])",
			"            {",
			"                if (it.f > 0 && level[it.v] == -1)",
			"                {",
			"                    level[it.v] = level[u] + 1;",
			"                    que.push(it.v);",
			"                }",
			"            }",
			"        }",
			"        return level[t] != -1;",
			"    }",
			"    int DFS(int u, int nf)",
			"    {",
			"        if (u == t)",
			"            return nf;",
			"        int res = 0;",
			"        for (auto &it : E[u])",
			"        {",
			"            if (it.f > 0 && level[it.v] == level[u] + 1)",
			"            {",
			"                int tf = DFS(it.v, min(nf, it.f));",
			"                res += tf;",
			"                nf -= tf;",
			"                it.f -= tf;",
			"                E[it.v][it.re].f += tf;",
			"                if (nf == 0)",
			"                    return res;",
			"            }",
			"        }",
			"        if (!res)",
			"            level[u] = -1;",
			"        return res;",
			"    }",
			"    int flow(int res = 0)",
			"    {",
			"        while (BFS())",
			"            res += DFS(s, 2147483647);",
			"        return res;",
			"    }",
			"} flow;",
        ]
    },
    "km": {
        "scope": "cpp",
        "prefix": "km",
        "body": [
			"vector<pair<int,int>> rot",
			"struct KM { // max weight, for min negate the weights",
			"int n, mx[MXN",
			"], my[MXN",
			"], pa[MXN",
			"];",
			"ll g[MXN",
			"][MXN",
			"], lx[MXN",
			"], ly[MXN",
			"], sy[MXN",
			"];",
			"bool vx[MXN",
			"], vy[MXN",
			"];",
			"void init(int _n) { // 1-based, N個節點",
			"n = _n;",
			"for (int i = 1; i <= n; i++)",
			"fill(g[i",
			"], g[i",
			"] + n + 1,",
			"0);",
			"}",
			"void addEdge(int x, int y, ll w) {",
			"g[x",
			"][y",
			"] = w;",
			"} //左邊的集合節點x連邊右邊集合節點y權重為w",
			"void augment(int y) {",
			"for (int x, z; y; y = z)",
			"x = pa[y",
			"], z = mx[x",
			"], my[y",
			"] = x, mx[x",
			"] = y;",
			"}",
			"void bfs(int st) {",
			"for (int i = 1; i <= n; ++i)",
			"sy[i",
			"] = INF, vx[i",
			"] = vy[i",
			"] = 0;",
			"queue<int> q;",
			"q.push(st);",
			"for (;;) {",
			"while (q.size()) {",
			"int x = q.front();",
			"q.pop();",
			"vx[x",
			"] = 1;",
			"for (int y = 1; y <= n; ++y)",
			"if (!vy[y",
			"]) {",
			"ll t = lx[x",
			"] + ly[y",
			"] - g[x",
			"][y",
			"];",
			"if (t == 0) {",
			"pa[y",
			"] = x;",
			"if (!my[y",
			"]) {",
			"augment(y);",
			"return;",
			"}",
			"vy[y",
			"] = 1, q.push(my[y",
			"]);",
			"} else if (sy[y",
			"] > t)",
			"pa[y",
			"] = x, sy[y",
			"] = t;",
			"}",
			"}",
			"ll cut = INF;",
			"for (int y = 1; y <= n; ++y)",
			"if (!vy[y",
			"] && cut > sy[y",
			"])",
			"cut = sy[y",
			"];",
			"for (int j = 1; j <= n; ++j) {",
			"if (vx[j",
			"])",
			"lx[j",
			"] -= cut;",
			"if (vy[j",
			"])",
			"ly[j",
			"] += cut;",
			"else",
			"sy[j",
			"] -= cut;",
			"}",
			"for (int y = 1; y <= n; ++y)",
			"if (!vy[y",
			"] && sy[y",
			"] == 0) {",
			"if (!my[y",
			"]) {",
			"augment(y);",
			"return;",
			"}",
			"vy[y",
			"] = 1, q.push(my[y",
			"]);",
			"}",
			"}",
			"}",
			"ll solve() { // 回傳值為完美匹配下的最大總權重",
			"fill(mx, mx + n + 1,",
			"0);",
			"fill(my, my + n + 1,",
			"0);",
			"fill(ly, ly + n + 1,",
			"0);",
			"fill(lx, lx + n + 1, -INF);",
			"for (int x = 1; x <= n; ++x)",
			"for (int y = 1; y <= n; ++y) // 1-base",
			"lx[x",
			"] = max(lx[x",
			"], g[x",
			"][y",
			"]);",
			"for (int x = 1; x <= n; ++x)",
			"bfs(x);",
			"ll ans = 0;",
			"for (int y = 1; y <= n; ++y) {",
			"ans += g[my[y",
			"]",
			"][y",
			"];",
			"rot.push_back(make_pair(my[y",
			"], y));",
			"}",
			"return ans;",
			"}",
			"} graph;",
        ]
    }
}